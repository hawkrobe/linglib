# Linglib Roadmap

This document tracks architectural improvements and technical debt to address in future work.

## High Priority

### 1. Intensional Montague Semantics

**Current state**: Montague meanings are extensional - evaluated in a fixed model, producing values like `Bool`.

**Problem**: RSA needs `meaning : World → Bool` to compute L0. Currently the RSA bridge is shallow - it pattern-matches on scalar items and returns pre-computed results rather than actually evaluating Montague meanings in RSA worlds.

**Solution**: Add an intensional layer where meanings are functions from worlds to extensions:

```lean
-- Current (extensional)
meaning : m.interpTy .t  -- just Bool

-- Desired (intensional)
meaning : World → Bool   -- varies with world
```

**Implementation path**:
1. Add `Montague/Intensional.lean` with world-parameterized types
2. Phenomena scenarios provide world structure + lexical interpretations
3. RSA's L0 evaluates the intensional meaning: `L0(u, w) = ⟦u⟧(w)`

**Files affected**: `Montague/Basic.lean`, `Montague/SemDerivation.lean`, `RSA/*.lean`

---

### 2. Type-Safe Scale Positions

**Current state**: Implicatures use string matching: `hasImplicature results "all"`

**Problem**: Fragile - renaming breaks silently, no compile-time checking.

**Solution**: Use the `QuantExpr` / `ConnExpr` types from `Montague/Scales.lean`:

```lean
-- Current
hasImplicature results "all"

-- Desired
hasImplicature results .all  -- type-checked!
```

**Files affected**: `NeoGricean/ScalarImplicatures.lean`, `RSA/ScalarImplicatures.lean`

---

### 3. Parameterized Lexicon for Competing Analyses

**Current state**: `Montague/Numbers.lean` has lower-bound semantics. Exact semantics proofs are scattered.

**Problem**: No clean way to compare competing semantic proposals (lower-bound vs exact numerals, Kratzer vs simple modals).

**Solution**: Parameterized lexicon structure:

```
Montague/Lexicon/
├── Numerals/
│   ├── LowerBound.lean   -- "two" means ≥2
│   └── Exact.lean        -- "two" means =2
├── Modals/
│   ├── Kratzer.lean      -- ordering source + modal base
│   └── Simple.lean       -- accessible worlds
└── Quantifiers/...
```

Each variant defines:
- Denotations
- Empirical predictions
- Which phenomena it handles/fails

**Files affected**: Create new `Lexicon/` structure, refactor `Numbers.lean`

---

## Medium Priority

### 4. Formal Language Theory & CCG Generative Capacity

**Current state**: `ccg_is_mildly_context_sensitive` is just an assertion (`rfl`), not a real proof.

**Problem**: Steedman's Chapter 6 makes substantive claims:
1. Cross-serial dependencies correspond to `{aⁿbⁿcⁿdⁿ}`
2. Pumping lemma proves this is not context-free
3. CCG with generalized composition can generate it
4. Therefore CCG is strictly more powerful than CFG

We assert (4) but don't prove (1)-(3).

**Solution**: Formalize the Chomsky hierarchy and prove CCG's position:

```
Core/FormalLanguageTheory.lean
  - FormalLanguage: Type → Type (sets of strings)
  - ContextFreeLanguage: recognized by CFG
  - MildlyContextSensitive: polynomial parsing, limited cross-serial
  - Pumping lemma for CFLs
  - Theorem: {aⁿbⁿcⁿdⁿ} is not context-free

Theories/CCG/GenerativeCapacity.lean
  - CCGLanguage: language generated by CCG grammar
  - Theorem: CCG generates {aⁿbⁿcⁿdⁿ} (via B² composition)
  - Theorem: CCG ⊃ CFL (strictly)
  - Theorem: CCG parsing is polynomial (sketch/cite)
```

**Key insight to formalize**: Forward crossed composition `X/Y (Y\Z)$ ⇒ (X\Z)$` allows verbs to "thread" arguments, producing crossed dependencies that pumping lemma rules out for CFG.

**References**:
- Steedman (2000) "The Syntactic Process" Ch. 6
- Vijay-Shanker & Weir (1994) "The equivalence of four extensions of CFGs"
- Joshi (1985) "Tree adjoining grammars" (defines mild context-sensitivity)

**Files affected**: New `Core/FormalLanguageTheory.lean`, new `Theories/CCG/GenerativeCapacity.lean`

---

### 5. Unify Example Derivations

**Current state**: Example derivations (`someStudentsSleep`, etc.) live in `SemDerivation.lean`.

**Problem**: These are used by both NeoGricean and RSA - awkward location.

**Solution**: Create `Examples/ScalarImplicature.lean` or similar with shared test cases.

---

### 6. CCG-Montague Homomorphism

**Current state**: `CCG/Semantics.lean` has `catToTy` mapping and trivial type preservation theorems. `CCG/TruthConditions.lean` has working pipeline.

**Problem**: The homomorphism property (syntactic composition → semantic application) is not formally proven.

**Solution**: Prove the fundamental theorem of compositional semantics:
```lean
theorem fapp_homomorphism :
    (DerivStep.fapp d₁ d₂).eval m lex = apply (d₁.eval m lex) (d₂.eval m lex)
```

See `docs/plans/wise-wiggling-parrot.md` for full plan.

**Files affected**: `CCG/Homomorphism.lean` (new), `CCG/Combinators.lean` (new)

---

### 7. RSA DE Context Handling

**Current state**: NeoGricean handles DE blocking; RSA doesn't.

**Problem**: The RSA bridge ignores context polarity.

**Solution**: Extend `rsaFromDerivation` to handle DE contexts, or document why RSA's treatment differs.

---

## Lower Priority

### 8. Reorganize Pragmatic Theories

**Current state**: `NeoGricean/` and `RSA/` are top-level under `Theories/`.

**Problem**: Inconsistent with the syntax/semantics/pragmatics layering. Both are pragmatic theories.

**Solution**: Move under `Theories/Pragmatics/`:
```
Theories/Pragmatics/
├── NeoGricean/
├── RSA/
└── Comparison.lean  (currently PragmaticComparison.lean)
```

**Files affected**: All imports of `NeoGricean.*` and `RSA.*` (~20 files)

---

### 9. HPSG/Minimalism → SemDerivation

**Current state**: Only CCG implements the syntax→semantics interface.

**Problem**: Other theories can't feed into pragmatics.

**Solution**: Implement `toDerivation` for HPSG and Minimalism.

---

### 10. Embedded Implicatures

**Current state**: Only simple sentences handled.

**Problem**: "John believes some students passed" has complex implicature patterns.

**Solution**: Extend derivation structure to track embedding; implement Geurts' analysis.

---

### 11. RSA α Parameter

**Current state**: RSA uses fixed rationality.

**Problem**: Can't model gradient speaker optimality / competence.

**Solution**: Parameterize RSA by α; relate to NeoGricean competence assumption.

---

## Architectural Principles

1. **Syntax-agnostic pragmatics**: Pragmatics imports `SemDerivation`, not specific syntax theories
2. **Phenomena-driven**: Empirical data in `Phenomena/`, theory coverage tracked
3. **Competing analyses explicit**: Different semantic proposals in separate files with empirical predictions
4. **Proofs over examples**: Prefer theorems to `#eval` demonstrations

---

## Completed

- [x] Consolidate `ContextPolarity` (was duplicated in SemDeriv and Alternatives)
- [x] Move `Comparison.lean` to `Theories/Pragmatics/`
- [x] End-to-end scalar implicature pipeline (CCG → Montague → NeoGricean/RSA)
- [x] Agreement theorem: both theories derive "not all" from "some"
- [x] CCG Compositional Semantics (`CCG/Semantics.lean`, `CCG/TruthConditions.lean`)
- [x] Scope interfaces (`Core/Interfaces/ScopeTheory.lean`, `Montague/Scope.lean`, `CCG/Scope.lean`)
- [x] Information Structure (`Core/InformationStructure.lean`, `CCG/Intonation.lean`)
- [x] Cross-serial dependencies (`Phenomena/CrossSerialDependencies/Data.lean`, `CCG/CrossSerial.lean`)
- [x] Coreference theory interface (`Core/Interfaces/CoreferenceTheory.lean`)
- [x] Pipeline architecture (`Core/Pipeline.lean`)
- [x] RSA scope ambiguity model (`RSA/ScontrasPearl2021.lean`)
- [x] Gapping word order typology (`Phenomena/Gapping/Data.lean`, `CCG/Gapping.lean`)

---

## Future Work

### 12. CCG Gapping Derivations & Category Decomposition

**Current state**: `CCG/Gapping.lean` defines gapped constituent categories and proves Ross's generalization emerges from CCG, but doesn't implement full derivations.

**Problem**: To actually build "Warren, potatoes" as `S\((S/NP)/NP)`, we need:
1. **Generalized backward composition for type-raised categories**:
   ```
   T\(T/NP₁)  T\(T/NP₂)  →  T\((T/NP₂)/NP₁)
   ```
   Standard backward composition (Y\Z X\Y → X\Z) doesn't directly give this.

2. **Category decomposition rule** (§7.3.3): Reveals "virtual constituents" from the left conjunct using parametric neutrality of combinatory rules.

3. **θ" anaphor**: Recovers gap interpretation from Information Structure (theme of left conjunct).

**Solution**:
```
Theories/CCG/Gapping.lean (extend)
  - GeneralizedBackwardComp: for type-raised categories
  - Full derivation: warren_potatoes builds S\((S/NP)/NP)
  - Theorem: derivation produces correct category

Theories/CCG/CategoryDecomposition.lean (new)
  - VirtualConjunctRule: X:left ⟹ Y:θ"left  X\Y:λy.left
  - Parametric neutrality: any two categories determine the third
  - Integration with Information Structure (Chapter 5)
```

**Key insight**: Category decomposition uses the grammar's own rules "in reverse" to reveal virtual constituents, preserving the Principles of Adjacency, Consistency, and Inheritance.

**References**:
- Steedman (2000) "The Syntactic Process" §7.3.3
- Pareschi & Steedman (1987) on parametric neutrality

**Files affected**: `CCG/Gapping.lean`, new `CCG/CategoryDecomposition.lean`
