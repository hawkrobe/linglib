import Linglib.Theories.IntensionalSemantics.Modal.Kratzer
import Linglib.Core.Presupposition
import Linglib.Core.CommonGround

/-!
# Kernel Semantics for Epistemic Modals

Von Fintel & Gillies (2010, 2021) kernel semantics. Epistemic modals carry an
evidential presupposition that the prejacent is not *directly settled* by the
kernel K ⊆ B_K. The central result (`entailment_settling_gap`) is that B_K can
entail φ without K directly settling it, making the presupposition non-trivial.

The 2021 paper extends the analysis to *can't*, exposing a dilemma for the
weakness Mantra: no assignment of force to *can't* simultaneously explains its
evidential distribution (Observation 4) and its incompatibility with *it's
possible* (Observation 5). Kernel semantics resolves this because *can't φ* =
*must*(¬φ) is simultaneously strong and evidentially constrained.

## References

- von Fintel, K. & Gillies, A. (2010). Must...stay...strong! NLS 18:351–383.
- von Fintel, K. & Gillies, A. (2021). Still going strong. NLS 29:91–113.
-/

namespace IntensionalSemantics.Modal

open IntensionalSemantics.Attitude.Intensional
open IntensionalSemantics.Modal.Kratzer
open Core.Presupposition
open Core.Proposition
open Core.CommonGround

/-! ## Helpers -/

/-- `(L.filter f).isEmpty = L.all (λ x => !f x)`: a filtered list is empty
iff every element fails the predicate. -/
private theorem filter_isEmpty_eq_all_not {α : Type}
    (L : List α) (f : α → Bool) :
    (L.filter f).isEmpty = L.all (λ x => !f x) := by
  induction L with
  | nil => rfl
  | cons a t ih =>
    cases hfa : f a <;> simp_all [List.isEmpty]

/-- `propIntersection (φ :: A) = (propIntersection A).filter φ`:
adding a proposition to the list intersects the base with ⟦φ⟧. -/
private theorem propIntersection_cons (φ : BProp World) (A : List (BProp World)) :
    propIntersection (φ :: A) = (propIntersection A).filter φ := by
  unfold propIntersection
  rw [List.filter_filter]
  apply List.filter_congr
  intro w _
  simp only [List.all_cons]

/-! ## Kernel structure (VF&G 2010 Def 4) -/

/-- A kernel: a set of direct-information propositions with B_K = ⋂K. -/
structure Kernel where
  props : List (BProp World)

namespace Kernel

/-- B_K = ⋂K. -/
def base (k : Kernel) : List World :=
  propIntersection k.props

/-- Convert to a context-independent modal base. -/
def toModalBase (k : Kernel) : ModalBase :=
  λ _ => k.props

/-- Consistency: B_K ≠ ∅. -/
def isConsistent (k : Kernel) : Bool :=
  Kratzer.isConsistent k.props

/-- φ follows from K iff B_K ⊆ ⟦φ⟧. -/
def followsFrom (k : Kernel) (φ : BProp World) : Bool :=
  Kratzer.followsFrom φ k.props

/-- Induce an `EpistemicFlavor` for Kratzer modal evaluation. -/
def toEpistemicFlavor (k : Kernel) : EpistemicFlavor where
  evidence := k.toModalBase
  ordering := emptyBackground

/-- View a common ground as a kernel. -/
def ofCG (cg : CG World) : Kernel where
  props := cg.propositions

end Kernel

/-- World-dependent kernel assignment K^c(w). -/
abbrev KernelBackground := World → Kernel

namespace KernelBackground

/-- Convert to a Kratzer modal base. -/
def toModalBase (kb : KernelBackground) : ModalBase :=
  λ w => (kb w).props

end KernelBackground

/-! ## Settling (VF&G 2010 Def 5) -/

/-- K directly settles P iff some X ∈ K entails P or is incompatible with P
(Implementation 1). -/
def directlySettlesExplicit (k : Kernel) (φ : BProp World) : Bool :=
  k.props.any λ x =>
    (propExtension x).all φ ||          -- X ⊆ ⟦φ⟧
    !(propExtension x).any φ            -- X ∩ ⟦φ⟧ = ∅

/-- Refine a partition along φ-boundaries (VF&G 2010 subject matter). -/
def refine (partition : List (List World)) (φ : BProp World) : List (List World) :=
  partition.flatMap λ cell =>
    let pos := cell.filter φ
    let neg := cell.filter (λ w => !φ w)
    [pos, neg].filter (·.length > 0)

/-- The partition S_K generated by K (VF&G 2010 Def 7). -/
def kernelPartition (k : Kernel) : List (List World) :=
  k.props.foldl refine [allWorlds]

/-- K settles P via partition iff P is a union of cells in S_K
(Implementation 2). -/
def settlesByPartition (k : Kernel) (φ : BProp World) : Bool :=
  let sK := kernelPartition k
  sK.all λ cell => cell.all φ || cell.all (λ w => !φ w)

/-- Implementation 1 ⊆ Implementation 2. -/
theorem explicit_implies_partition (k : Kernel) (φ : BProp World)
    (_h : directlySettlesExplicit k φ = true) :
    settlesByPartition k φ = true := by
  sorry -- Requires showing refine along any X ∈ K that entails/excludes φ
  -- produces cells uniformly within/outside ⟦φ⟧.

/-! ## Modal operators (VF&G 2010 Defs 5–6) -/

/-- ⟦must φ⟧: presupposes K doesn't settle φ; asserts B_K ⊆ ⟦φ⟧. -/
def kernelMust (k : Kernel) (φ : BProp World) : PrProp World :=
  { presup := λ _ => !directlySettlesExplicit k φ
  , assertion := λ _ => Kratzer.followsFrom φ k.props }

/-- ⟦might φ⟧: presupposes K doesn't settle φ; asserts B_K ∩ ⟦φ⟧ ≠ ∅. -/
def kernelMight (k : Kernel) (φ : BProp World) : PrProp World :=
  { presup := λ _ => !directlySettlesExplicit k φ
  , assertion := λ _ => isCompatibleWith φ k.props }

/-- ⟦can't φ⟧ = must(¬φ). -/
def kernelCant (k : Kernel) (φ : BProp World) : PrProp World :=
  kernelMust k (λ w => !φ w)

/-- World-dependent ⟦must φ⟧. -/
def kernelMustW (kb : KernelBackground) (φ : BProp World) : PrProp World :=
  { presup := λ w => !directlySettlesExplicit (kb w) φ
  , assertion := λ w => Kratzer.followsFrom φ (kb w).props }

/-- World-dependent ⟦might φ⟧. -/
def kernelMightW (kb : KernelBackground) (φ : BProp World) : PrProp World :=
  { presup := λ w => !directlySettlesExplicit (kb w) φ
  , assertion := λ w => isCompatibleWith φ (kb w).props }

/-! ## Core properties -/

/-- Must is strong: when defined, must φ = universal necessity over B_K. -/
theorem must_is_strong (k : Kernel) (φ : BProp World) (w : World)
    (_hDef : (kernelMust k φ).presup w = true) :
    (kernelMust k φ).assertion w = simpleNecessity k.toModalBase φ w := by
  unfold kernelMust simpleNecessity accessibleWorlds Kernel.toModalBase followsFrom
  rfl

/-- T axiom: must φ entails φ when B_K is realistic (w ∈ B_K). -/
theorem must_entails_prejacent (k : Kernel) (φ : BProp World) (w : World)
    (hReal : w ∈ k.base)
    (_hDef : (kernelMust k φ).presup w = true)
    (hTrue : (kernelMust k φ).assertion w = true) :
    φ w = true := by
  unfold kernelMust at hTrue
  unfold followsFrom at hTrue
  unfold Kernel.base at hReal
  exact List.all_eq_true.mp hTrue w hReal

/-- Duality: might φ ↔ ¬(must ¬φ) in assertion content. -/
theorem kernel_duality (k : Kernel) (φ : BProp World) (w : World) :
    (kernelMight k φ).assertion w = !(kernelMust k (λ w' => !φ w')).assertion w := by
  simp only [kernelMight, kernelMust, isCompatibleWith, isConsistent, followsFrom]
  rw [propIntersection_cons, filter_isEmpty_eq_all_not]

/-- Empty kernel: nothing is settled, so must is always defined. -/
theorem empty_kernel_always_defined (φ : BProp World) (w : World) :
    (kernelMust ⟨[]⟩ φ).presup w = true := by
  simp only [kernelMust, directlySettlesExplicit, List.any_nil, Bool.not_false]

/-! ## Bridge to Kratzer.lean -/

/-- Kernel must assertion = Kratzer simple necessity. -/
theorem kernelMust_eq_simpleNecessity (k : Kernel) (φ : BProp World) (w : World) :
    (kernelMust k φ).assertion w = simpleNecessity k.toModalBase φ w := by
  unfold kernelMust simpleNecessity accessibleWorlds Kernel.toModalBase followsFrom
  rfl

/-! ## Mastermind example (VF&G 2010 pp. 365–366)

w0 = red, w1 = blue, w2 = green, w3 = unknown.
K = {redOrBlue, notRed}, B_K = {w1}. -/

private def redOrBlue : BProp World := λ w => match w with | .w0 => true | .w1 => true | _ => false
private def notRed : BProp World := λ w => match w with | .w0 => false | _ => true
private def blue : BProp World := λ w => match w with | .w1 => true | _ => false
private def red : BProp World := λ w => match w with | .w0 => true | _ => false
private def notBlue : BProp World := λ w => match w with | .w1 => false | _ => true

private def mastermindK : Kernel := ⟨[redOrBlue, notRed]⟩
private def indirectK : Kernel := ⟨[redOrBlue]⟩

theorem mastermind_base : mastermindK.base = [.w1] := by native_decide

theorem mastermind_blue_unsettled :
    directlySettlesExplicit mastermindK blue = false := by native_decide

theorem mastermind_blue_follows :
    mastermindK.followsFrom blue = true := by native_decide

theorem mastermind_must_blue_defined :
    (kernelMust mastermindK blue).presup .w0 = true := by native_decide

theorem mastermind_must_blue_true :
    (kernelMust mastermindK blue).assertion .w0 = true := by native_decide

theorem mastermind_red_settled :
    directlySettlesExplicit mastermindK red = true := by native_decide

theorem mastermind_might_red_undefined :
    (kernelMight mastermindK red).presup .w0 = false := by native_decide

theorem mastermind_redOrBlue_settled :
    directlySettlesExplicit mastermindK redOrBlue = true := by native_decide

/-! ## Deep theorems (VF&G 2010) -/

/-- **Entailment-settling gap**: B_K can entail φ without K settling it.
This gap makes the evidential presupposition non-trivial: must φ can be
simultaneously defined and true. -/
theorem entailment_settling_gap :
    ∃ (k : Kernel) (φ : BProp World),
      k.followsFrom φ = true ∧ directlySettlesExplicit k φ = false :=
  ⟨mastermindK, blue, by native_decide, by native_decide⟩

/-- **Indirectness ≠ weakness**: three independent cases show indirectness
and assertion strength are orthogonal dimensions. -/
theorem indirectness_neq_weakness :
    ((kernelMust mastermindK blue).presup .w0 = true ∧
     (kernelMust mastermindK blue).assertion .w0 = true) ∧
    (kernelMust mastermindK red).presup .w0 = false ∧
    ((kernelMust indirectK blue).presup .w0 = true ∧
     (kernelMust indirectK blue).assertion .w0 = false) := by native_decide

/-- **Modus ponens with must** (VF&G 2010 Arg 4.3.1): the argument form
"if φ, must ψ; φ; ∴ ψ" is valid under realistic B_K. -/
theorem modus_ponens_with_must (k : Kernel) (φ ψ : BProp World) (w : World)
    (hReal : w ∈ k.base)
    (_hDef : (kernelMust k ψ).presup w = true)
    (hCond : φ w = true → (kernelMust k ψ).assertion w = true)
    (hPhi : φ w = true) :
    ψ w = true :=
  must_entails_prejacent k ψ w hReal _hDef (hCond hPhi)

/-- **Must-perhaps contradiction** (VF&G 2010 Arg 4.3.2): must φ ∧ might ¬φ
is contradictory. When B_K ⊆ ⟦φ⟧, we have B_K ∩ ⟦¬φ⟧ = ∅. -/
theorem must_perhaps_contradiction (k : Kernel) (φ : BProp World) (w : World)
    (_hDef : (kernelMust k φ).presup w = true)
    (hMust : (kernelMust k φ).assertion w = true) :
    (kernelMight k (λ w' => !φ w')).assertion w = false := by
  rw [kernel_duality]
  simp only [kernelMust] at hMust ⊢
  simp only [followsFrom, propIntersection] at hMust ⊢
  simp [hMust]

/-- Direct evidence infelicity: when K settles φ, must φ is undefined. -/
theorem direct_evidence_infelicity (k : Kernel) (φ : BProp World) (w : World)
    (hSettled : directlySettlesExplicit k φ = true) :
    (kernelMust k φ).presup w = false := by
  simp only [kernelMust, hSettled, Bool.not_true]

/-- Settling is monotone: more propositions in K means more is settled. -/
theorem settling_monotone (k : Kernel) (p : BProp World) (φ : BProp World)
    (hSettled : directlySettlesExplicit k φ = true) :
    directlySettlesExplicit ⟨p :: k.props⟩ φ = true := by
  simp only [directlySettlesExplicit, List.any_cons] at *
  simp [hSettled]

/-! ## Can't dilemma (VF&G 2021 §4, Observations 4–5)

The Mantra faces a dilemma: no assignment of force to *can't* simultaneously
explains its evidential distribution (paralleling must) and its incompatibility
with *it's possible that φ*. Kernel semantics resolves this because
*can't φ* = *must*(¬φ) is strong AND evidentially constrained. -/

/-- **Can't–might exclusion** (VF&G 2021 Obs 5): when can't φ holds
(B_K ⊆ ⟦¬φ⟧), might φ is false (B_K ∩ ⟦φ⟧ = ∅). -/
theorem cant_might_exclusion (k : Kernel) (φ : BProp World) (w : World)
    (hCant : (kernelCant k φ).assertion w = true) :
    (kernelMight k φ).assertion w = false := by
  rw [kernel_duality]
  simp only [kernelCant, kernelMust] at hCant ⊢
  simp only [followsFrom, propIntersection] at hCant ⊢
  simp [hCant]

/-- **Can't entails negation** (VF&G 2021 via S2): when B_K is realistic
and can't φ is defined and true, φ(w) = false. -/
theorem cant_entails_negation (k : Kernel) (φ : BProp World) (w : World)
    (hReal : w ∈ k.base)
    (_hDef : (kernelCant k φ).presup w = true)
    (hTrue : (kernelCant k φ).assertion w = true) :
    φ w = false := by
  have hNeg := must_entails_prejacent k (λ w' => !φ w') w hReal _hDef hTrue
  simp only [Bool.not_eq_true'] at hNeg
  exact hNeg

/-- **Can't evidential parallelism** (VF&G 2021 Obs 4): can't φ has the
same presupposition structure as must(¬φ). -/
theorem cant_evidential_parallel (k : Kernel) (φ : BProp World) (w : World) :
    (kernelCant k φ).presup w = (kernelMust k (λ w' => !φ w')).presup w := rfl

/-- **Can't dilemma resolved**: a single kernel simultaneously exhibits
evidentiality, strength, and might-exclusion.
Witness: K = {redOrBlue, notRed}, φ = notBlue. Then can't(notBlue) =
must(blue), which is defined (blue unsettled), true (B_K ⊆ ⟦blue⟧),
and excludes might(notBlue). -/
theorem cant_dilemma_resolved :
    mastermindK.base.elem .w1 = true ∧
    (kernelCant mastermindK notBlue).presup .w1 = true ∧
    (kernelCant mastermindK notBlue).assertion .w1 = true ∧
    (kernelMight mastermindK notBlue).assertion .w1 = false ∧
    notBlue .w1 = false := by native_decide

/-- Direct evidence blocks can't, paralleling must: when K settles ¬φ,
can't φ has presupposition failure. -/
theorem cant_direct_evidence_infelicity :
    (kernelCant mastermindK red).presup .w0 = false := by native_decide

/-- can't φ and must(¬φ) are intensionally identical. -/
theorem cant_eq_must_neg (k : Kernel) (φ : BProp World) (w : World) :
    (kernelCant k φ).presup w = (kernelMust k (λ w' => !φ w')).presup w ∧
    (kernelCant k φ).assertion w = (kernelMust k (λ w' => !φ w')).assertion w :=
  ⟨rfl, rfl⟩

/-! ## Prior information state and nandao-Q felicity (Zheng 2026)

Zheng (2026) shows Mandarin *nandao*-Qs are evidence-driven, not bias-driven.
The felicity condition has three parts: (i) evidence in K supports the prejacent,
(ii) K conflicts with prior expectations U, (iii) the prejacent is not directly
settled in K. Condition (iii) is the same presupposition as `kernelMust`. -/

/-- Prior information state (beliefs, norms, desires) before encountering
evidence. Distinct from the kernel (direct evidence) and the CG (shared). -/
abbrev Background := List (BProp World)

/-- B_U = ⋂U: worlds compatible with the prior information state. -/
def backgroundBase (u : Background) : List World :=
  propIntersection u

/-- K and U are incompatible: B_K ∩ B_U = ∅ (the evidence is unexpected). -/
def Kernel.incompatibleWith (k : Kernel) (u : Background) : Bool :=
  !(Kratzer.isConsistent (k.props ++ u))

/-- Evidence p raises the probability of φ: P(φ|p) > P(φ).
Computed via cross-multiplication to avoid rationals. -/
def evidenceRaises (p φ : BProp World) : Bool :=
  let pWorlds := propExtension p
  let phiInP := (pWorlds.filter φ).length
  let phiInAll := (allWorlds.filter φ).length
  phiInP * allWorlds.length > phiInAll * pWorlds.length

/-- Some proposition in K raises the probability of φ (condition i). -/
def Kernel.evidenceSupports (k : Kernel) (φ : BProp World) : Bool :=
  k.props.any (evidenceRaises · φ)

/-- **Nandao-Q felicity** (Zheng 2026, condition 11 for polar questions):
(i) some evidence in K raises P(φ),
(ii) K and U are incompatible (evidence is unexpected),
(iii) φ is not directly settled in K. -/
def nandaoFelicitous (k : Kernel) (u : Background) (φ : BProp World) : Bool :=
  k.evidenceSupports φ &&
  k.incompatibleWith u &&
  !directlySettlesExplicit k φ

/-- Nandao condition (iii) = presupposition of `kernelMust`. -/
theorem nandao_must_presupposition (k : Kernel) (φ : BProp World) (w : World) :
    (!directlySettlesExplicit k φ) = (kernelMust k φ).presup w := rfl

/-- Pure inquiry: nandao is felicitous without epistemic bias (Zheng 2026 ex. 3).
The three conditions suffice; no prior belief about φ is required. -/
theorem nandao_pure_inquiry (k : Kernel) (u : Background) (φ : BProp World)
    (hEv : k.evidenceSupports φ = true)
    (hInc : k.incompatibleWith u = true)
    (hUns : directlySettlesExplicit k φ = false) :
    nandaoFelicitous k u φ = true := by
  simp only [nandaoFelicitous, hEv, hInc, hUns, Bool.not_false, Bool.true_and]

/-! ### Dripping raincoat scenario (Zheng 2026 exx. 2–3, 5)

w0 = raining, w1 = sprinkler (wet but not rain), w2 = dry, w3 = unknown.
K = {wearingRaincoat}: direct evidence that someone entered with a wet coat.
U = {expectDry}: prior expectation of no rain (normative or doxastic). -/

private def wearingRaincoat : BProp World :=
  λ w => match w with | .w0 => true | .w1 => true | _ => false
private def expectDry : BProp World :=
  λ w => match w with | .w2 => true | .w3 => true | _ => false
private def isRaining : BProp World :=
  λ w => match w with | .w0 => true | _ => false

private def raincoatK : Kernel := ⟨[wearingRaincoat]⟩
private def dryU : Background := [expectDry]

/-- "Nandao waimian xiayu-le ma?" is felicitous with a dripping raincoat.
P(rain|coat) = 1/2 > P(rain) = 1/4; K ∩ U = ∅; rain unsettled by K. -/
theorem raincoat_nandao_felicitous :
    nandaoFelicitous raincoatK dryU isRaining = true := by native_decide

/-- Without evidence, nandao is infelicitous (Zheng 2026 ex. 5 ctx 2). -/
theorem no_evidence_nandao_infelicitous :
    nandaoFelicitous ⟨[]⟩ dryU isRaining = false := by native_decide

/-- When evidence is expected (K compatible with U), nandao is infelicitous
(Zheng 2026 ex. 6 ctx 2). -/
theorem expected_evidence_infelicitous :
    let expectWet : Background := [wearingRaincoat]
    nandaoFelicitous raincoatK expectWet isRaining = false := by native_decide

/-- Nandao reuses the mastermind kernel: "must blue" and "nandao blue?" share
condition (iii). When must is defined, nandao's indirectness condition holds. -/
theorem nandao_mastermind_bridge :
    (kernelMust mastermindK blue).presup .w0 = true ∧
    !directlySettlesExplicit mastermindK blue = true := by native_decide

end IntensionalSemantics.Modal
