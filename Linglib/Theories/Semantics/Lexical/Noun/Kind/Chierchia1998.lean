/-
# Kind-Level Semantics (Chierchia 1998)

Formalizes Chierchia's "Reference to Kinds Across Languages" framework for
bare plural composition and the Nominal Mapping Parameter.

## The Core Insight

Languages vary in what they let their NPs denote:
- [+arg, -pred]: NPs denote kinds (Chinese) → bare arguments everywhere
- [+arg, +pred]: NPs can be kinds or predicates (Germanic) → bare plurals/mass
- [-arg, +pred]: NPs denote predicates (Romance) → D required for arguments

## Key Operators

1. ∩ (down): ⟨s,⟨e,t⟩⟩ → e — nominalize property to kind
2. ∪ (up): e → ⟨e,t⟩ — predicativize kind to property
3. DKP: Derived Kind Predication — coerce object predicates to kind predicates

## Ontology

Following Link (1983) and Chierchia (1998):
- Domain U is a complete atomic join semilattice
- Atoms are singular individuals
- Non-atoms are pluralities (modeled as sets)
- Kinds are individual concepts: functions from worlds to pluralities
- Kinds ⊆ U^S (subset of individual concepts)

We model `Individual Atom` as `Set Atom`. Atoms are singletons `{a}`,
pluralities are larger sets. `PartialOrder` (⊆) and `SemilatticeSup` (∪)
come from Mathlib for free, giving us Link's semilattice directly.

## References

- Chierchia, G. (1998). Reference to Kinds Across Languages.
- Carlson, G. (1977). Reference to Kinds in English.
- Link, G. (1983). The Logical Analysis of Plural and Mass Nouns.
- Partee, B. (1987). Noun Phrase Interpretation and Type-Shifting Principles.
-/

import Mathlib.Data.Set.Basic
import Mathlib.Data.Fintype.Basic
import Mathlib.Order.UpperLower.Basic
import Linglib.Core.Mereology

namespace Semantics.Lexical.Noun.Kind.Chierchia1998

-- Domain Structure (Link's Semilattice)

/-- An individual is a non-empty set of atoms. Atoms are singletons `{a}`,
    pluralities are larger sets. The part-of relation (⊆) and join (∪)
    are inherited from Mathlib's `Set` instances, giving us Link's
    complete atomic join semilattice. -/
abbrev Individual (Atom : Type) := Set Atom

/-- Construct a singular individual from an atom. -/
def Individual.atom {Atom : Type} (a : Atom) : Individual Atom := {a}

-- Kinds as Individual Concepts

variable (World Atom : Type)

/-- A property (intension): function from worlds to sets of individuals -/
abbrev Property := World → Set (Individual Atom)

/-- An individual concept: function from worlds to individuals -/
abbrev IndividualConcept := World → Individual Atom

/--
Kinds are a special subset of individual concepts.

A kind is an individual concept that maps each world to the totality
of instances (a set of atoms) and represents a "natural" class with
regular behavior.

Not every individual concept is a kind. Only those corresponding to
natural properties qualify.
-/
structure Kind where
  /-- The underlying individual concept -/
  concept : IndividualConcept World Atom

-- The Down Operator: ∩ (Property → Kind)

/--
The "down" operator ∩ (cap): nominalize a property to a kind.

∩P = λs. ιPₛ

That is, at each world s, take the largest individual in the extension of P.
For plural/mass properties, this is the fusion of all instances.

Note: ∩ is only semantically defined for plural/mass nouns (see
`downDefinedFor`). This function computes the nominalization for any
property; the partiality constraint is enforced externally.
-/
def down (P : Property World Atom) : Kind World Atom :=
  { concept := λ w => { a : Atom | Individual.atom a ∈ P w } }

-- The Up Operator: ∪ (Kind → Property)

/--
The "up" operator ∪ (cup): predicativize a kind to a property.

∪k = λx[x ⊆ kₛ]

The extension is the ideal generated by the kind's instances:
all individuals that are "part of" the totality of instances.

Property: ∪ applied to a kind yields a MASS denotation.
This is because the extension includes both atoms and pluralities.
-/
def up (k : Kind World Atom) : Property World Atom :=
  λ w => { x | x ⊆ k.concept w }

-- Mass Noun Condition

/--
A property is mass iff its extension at every world is determined by
atomic content: `x ∈ P w ↔ ∀ a ∈ x, {a} ∈ P w` (Chierchia 1998 §2.2).

This implies both cumulative reference (CUM) and divisive reference (DIV):
mass extensions are closed under union and subset.
-/
def IsMass (P : Property World Atom) : Prop :=
  ∀ w (x : Individual Atom), x ∈ P w ↔ ∀ a ∈ x, Individual.atom a ∈ P w

-- Bridge Theorems to Core/Mereology

section MereologyBridge

variable {World Atom : Type}

/-- Mass properties have divisive reference: if `x ∈ P w` and `y ⊆ x`,
    then `y ∈ P w`. Every part of a mass-noun instance is also an instance. -/
theorem isMass_div (P : Property World Atom) (hMass : IsMass World Atom P) (w : World) :
    Mereology.DIV (P w) :=
  fun x y hx hyx => (hMass w y).mpr fun a ha => (hMass w x).mp hx a (hyx ha)

/-- Mass properties have cumulative reference: if `x ∈ P w` and `y ∈ P w`,
    then `x ∪ y ∈ P w`. Combining mass-noun instances yields an instance. -/
theorem isMass_cum (P : Property World Atom) (hMass : IsMass World Atom P) (w : World) :
    Mereology.CUM (P w) :=
  fun x y hx hy => (hMass w (x ⊔ y)).mpr fun a ha =>
    Or.elim ha (fun h => (hMass w x).mp hx a h) (fun h => (hMass w y).mp hy a h)

end MereologyBridge

-- Round-Trip Theorems

/--
Key theorem: ∪(∩P) = P for mass properties.

Going down and then up returns the original property (for suitable P).
The mass-noun condition `IsMass` ensures that the extension at each world
is determined by its atomic content, which is exactly what `down` extracts
and `up` reconstructs.
-/
theorem up_down_id (P : Property World Atom) (hMass : IsMass World Atom P) :
    up World Atom (down World Atom P) = P := by
  funext w; ext x
  simp only [up, down, Set.mem_setOf_eq]
  constructor
  · intro h; exact (hMass w x).mpr fun a ha => h ha
  · intro h a ha; exact (hMass w x).mp h a ha

/--
Key theorem: ∩(∪k) = k for any kind k.

Going up and then down returns the original kind.
-/
theorem down_up_id (k : Kind World Atom) :
    down World Atom (up World Atom k) = k := by
  simp only [down, up, Set.mem_setOf_eq, Individual.atom,
             Set.singleton_subset_iff, Set.setOf_mem_eq]

-- Derived Kind Predication (DKP)

/--
Derived Kind Predication: coerce object-level predicates to accept kinds.

When an object-level predicate P applies to a kind k, introduce
existential quantification over instances:

  P(k) = ∃x[∪k(x) ∧ P(x)]

This is a type-coercion triggered by sort mismatch.

Example: "Lions are roaring in the zoo"
- "lions" denotes a kind
- "roaring in the zoo" is an object-level predicate
- DKP yields: ∃x[lion(x) ∧ roaring-in-the-zoo(x)]
-/
def DKP (P : Individual Atom → Bool) (k : Kind World Atom) (w : World) : Prop :=
  ∃ x, x ∈ up World Atom k w ∧ P x = true

/--
DKP as a type-shifting operation on predicates.

Takes an object-level predicate and returns a kind-level predicate.
-/
def liftToKind (P : Individual Atom → Bool) : Kind World Atom → World → Prop :=
  λ k w => DKP World Atom P k w

-- The Nominal Mapping Parameter

/--
The Nominal Mapping Parameter (Chierchia 1998).

Languages vary in what they let their NPs denote:
- [+arg]: NPs can be argumental (type e, denoting kinds)
- [+pred]: NPs can be predicative (type ⟨e,t⟩)

The combination determines the language's nominal system.
-/
inductive NominalMapping where
  /-- [+arg, -pred]: All nouns are kinds (Chinese-like)
      - All nouns are mass-like
      - No plural morphology
      - Generalized classifier system
      - Bare arguments everywhere -/
  | argOnly
  /-- [+arg, +pred]: Nouns can be kinds or predicates (Germanic-like)
      - Mass/count distinction
      - Bare plurals and mass nouns as arguments
      - Singular count nouns require D -/
  | argAndPred
  /-- [-arg, +pred]: All nouns are predicates (Romance-like)
      - Mass/count distinction
      - Bare arguments restricted (need licensing)
      - D must be projected for argumenthood -/
  | predOnly
  deriving DecidableEq, Repr

/-- Language family classification -/
def languageFamily : NominalMapping → String
  | .argOnly => "Chinese, Japanese (classifier languages)"
  | .argAndPred => "English, German, Slavic (bare argument languages)"
  | .predOnly => "French, Italian, Spanish (Romance languages)"

-- Mass/Count Distinction

/--
The mass/count distinction in [+pred] languages.

Count nouns have atomic extensions (sets of atoms).
Mass nouns have non-atomic extensions (closed under parts).
-/
inductive NounType where
  | count  -- Extension is a set of atoms
  | mass   -- Extension is closed under the part-of relation
  deriving DecidableEq, Repr

/--
Pluralization / mass extension: the set of non-empty sub-individuals.

For count nouns, `PL(F) = { s | s.Nonempty ∧ s ⊆ F }` — the set of
pluralities whose atomic parts are all in the original extension.

Mass nouns come out of the lexicon "already pluralized": a mass noun like
"furniture" is true of individual pieces AND pluralities of pieces, without
distinction. Its extension has the same form: `{ s | s.Nonempty ∧ s ⊆ atoms }`.
-/
def pluralize {Atom : Type} (F : Set Atom) : Set (Individual Atom) :=
  { s | s.Nonempty ∧ s ⊆ F }

-- Type Shifting as Last Resort (Blocking Principle)

/--
The Blocking Principle: covert type shifting is blocked when an
overt determiner has the same meaning.

For any type shifting operation τ and any X:
  *τ(X) if there is a determiner D such that D(X) = τ(X)

In English:
- ι (iota) is blocked by "the" → can't use ι covertly
- ∃ is blocked by "a/some" for singulars → can't use ∃ covertly for singulars
- ∩ is NOT blocked → can use ∩ freely for bare plurals/mass

This explains why English allows bare plurals but not bare singulars.
-/
structure BlockingPrinciple where
  /-- Available overt determiners -/
  determiners : List String
  /-- Whether ι (definite) is blocked -/
  iotaBlocked : Bool := "the" ∈ determiners
  /-- Whether ∃ (indefinite singular) is blocked -/
  existsBlocked : Bool := "a" ∈ determiners ∨ "some" ∈ determiners
  /-- Whether ∩ (kind formation) is blocked -/
  downBlocked : Bool := False  -- Never blocked in natural languages

/-- Bare argument is licensed iff the required type shift is not blocked -/
def bareArgumentLicensed (bp : BlockingPrinciple) (nounType : NounType) : Bool :=
  match nounType with
  | .mass => !bp.downBlocked  -- Mass nouns use ∩, which is not blocked
  | .count => !bp.downBlocked  -- But only plurals can use ∩ (see below)

-- Why Bare Singulars Are Out

/--
The key insight: ∩ is undefined for singular count nouns.

∩ applied to a singular property would need to yield a kind.
But kinds necessarily have plurality of instances (across worlds).
A property that is necessarily instantiated by just one individual
does not qualify as a kind.

Therefore:
- ∩(dogs) = the dog-kind ✓
- ∩(dog) = undefined ✗

This, combined with blocking of ι and ∃ by articles, explains why
bare singular count nouns cannot occur as arguments in English.
-/
def downDefinedFor (nounType : NounType) (isPlural : Bool) : Bool :=
  match nounType with
  | .mass => true           -- Mass nouns can always use ∩
  | .count => isPlural      -- Count nouns can use ∩ only if plural

/--
Why bare plurals are OK but bare singulars are not (in languages with articles).

Given a language where:
- ι is blocked (has "the")
- ∃ is blocked for singulars (has "a")
- ∩ is not blocked

Then:
- Bare plurals OK: ∩ is defined and not blocked
- Bare singulars OUT: ∩ is undefined, and ι/∃ are blocked

Language-specific configurations live in Fragments/{Language}/Nouns.lean.
-/
theorem bare_plural_ok_bare_singular_not (bp : BlockingPrinciple)
    (hIota : bp.iotaBlocked = true)
    (hExists : bp.existsBlocked = true) :
    downDefinedFor .count true = true ∧
    downDefinedFor .count false = false ∧
    bp.iotaBlocked = true ∧
    bp.existsBlocked = true := by
  simp [hIota, hExists, downDefinedFor]

-- Scopelessness (Theoretical Basis)

/--
Bare plurals are scopeless because DKP introduces a LOCAL existential.

The existential reading from DKP cannot scope out because the coercion
applies inside the predicate abstract.

See `Phenomena/KindReference/Data.lean` for empirical scope data.
-/
def dkpIsLocal : Bool := true

/--
When ∩ is undefined (NP doesn't denote a kind), we fall back to ∃.

For non-kind-denoting NPs like "parts of that machine":
- ∩ is undefined (no corresponding natural kind)
- ∃ is available (not blocked for plurals)
- Result: these NPs behave like regular existential GQs
-/
def fallbackToExists (isKindDenoting : Bool) (bp : BlockingPrinciple) : Bool :=
  !isKindDenoting ∧ !bp.existsBlocked

-- DKP Derivation Machinery (for Scrambling Comparison)

/-!
## Computational DKP

Simplified, decidable formalization of Chierchia's DKP for concrete
scrambling comparisons with Krifka (2004). Uses `List Entity` and `Bool`
(rather than `Set Atom` and `Prop`) so that examples reduce by `rfl`.

The parallel Krifka machinery is in `Krifka2004.lean`; both are
instantiated side-by-side in `Phenomena/Generics/Compare.lean`.

See `Theories/Comparisons/KindReference.lean` for the formal comparison.
-/

section DKPDerivation

variable {Entity World : Type}

/-- A kind's extension at each world (the instances) -/
abbrev KindExtension (Entity World : Type) := World → List Entity

/-- A VP meaning (intensional) -/
abbrev ChierchiaVP (Entity World : Type) := Entity → World → Bool

/-- A sentence meaning (proposition) -/
abbrev ChierchiaSent (World : Type) := World → Bool

/--
DKP (Derived Kind Predication): Coerce a kind to work with object-level predicates.

Given a kind (represented by its extension at each world) and an object-level VP,
DKP introduces existential quantification:

  DKP(VP)(k) = λw. ∃x ∈ k(w). VP(x)(w)

Property: The ∃ is introduced HERE, at the point of composition,
not at a syntactic position. This makes DKP position-invariant.
-/
def dkpApply
    (kind : KindExtension Entity World)
    (vp : ChierchiaVP Entity World)
    : ChierchiaSent World :=
  λ w => (kind w).any (λ x => vp x w)

/--
Chierchia's derivation for "[niet [BP V]]" (unscrambled).

1. BP = kind k
2. VP = λx.V(x)
3. DKP: ∃x[k(x) ∧ V(x)]
4. Negation: ¬∃x[k(x) ∧ V(x)]
-/
def chierchiaDerivUnscrambled
    (kind : KindExtension Entity World)
    (vp : ChierchiaVP Entity World)
    : ChierchiaSent World :=
  λ w => !(dkpApply kind vp w)

/--
Chierchia's derivation for "[BP [niet V]]" (scrambled).

In Chierchia's system, scrambling doesn't change the derivation.
DKP still applies when the kind meets the predicate, and the ∃
is introduced at that point (the trace position in LF).

Result: Same as unscrambled — ¬∃x[k(x) ∧ V(x)]
-/
def chierchiaDerivScrambled
    (kind : KindExtension Entity World)
    (vp : ChierchiaVP Entity World)
    : ChierchiaSent World :=
  -- Scrambling is invisible to DKP — same derivation
  λ w => !(dkpApply kind vp w)

/--
Chierchia's DKP is position-invariant.

Scrambled and unscrambled derivations yield the same meaning.
This is the source of Chierchia's incorrect prediction for Dutch scrambling.
-/
theorem chierchia_position_invariant
    (kind : KindExtension Entity World)
    (vp : ChierchiaVP Entity World)
    : chierchiaDerivScrambled kind vp = chierchiaDerivUnscrambled kind vp := rfl

end DKPDerivation

-- Theory Verification

/-- ∩ is defined for plural count nouns -/
example : downDefinedFor .count true = true := rfl

/-- ∩ is undefined for singular count nouns -/
example : downDefinedFor .count false = false := rfl

/-- ∩ is always defined for mass nouns -/
example : downDefinedFor .mass true = true := rfl
example : downDefinedFor .mass false = true := rfl

/-!
## Related Theory

- `Theories/Montague/Lexicon/Krifka2004.lean` - Alternative: Bare NPs as properties
- `Theories/Montague/Lexicon/Dayal2004.lean` - Meaning Preservation, singular kinds
- `Theories/Montague/Lexicon/Generics.lean` - GEN operator for generic readings

## Empirical Data

For empirical patterns (cross-linguistic data, scope judgments, predicate
class effects), see:
- `Phenomena/KindReference/Data.lean` - unified kind reference phenomena
- `Phenomena/BarePlurals/Data.lean` - generic vs existential readings
- `Phenomena/Generics/Data.lean` - generic sentence patterns
-/

-- ============================================================================
-- Kind Formation via Equivalence Relations (Mendia 2020, Snyder 2026 §4.1)
-- ============================================================================

section KindFormation

/-- An equivalence relation on atoms partitions them into subkinds. -/
structure KindFormation (Atom : Type) where
  /-- The salient equivalence relation -/
  rel : Atom → Atom → Prop
  /-- Must be an equivalence -/
  isEquiv : Equivalence rel

/-- Subkind relation: k₁ is a subkind of k₂ iff every
    entity instantiating k₁ also instantiates k₂. -/
def isSubkindOf {Atom : Type} (k₁ k₂ : Set Atom) : Prop :=
  k₁ ⊆ k₂

/-- Carlson's (1977) Disjointness Condition: subkinds induced by an
    equivalence relation are pairwise disjoint in any context. -/
theorem disjointness_condition {Atom : Type} [DecidableEq Atom]
    (kf : KindFormation Atom) (a b : Atom) (h : ¬kf.rel a b) :
    Disjoint {x | kf.rel a x} {x | kf.rel b x} := by
  rw [Set.disjoint_iff]
  intro x ⟨ha, hb⟩
  have hxa : kf.rel x a := kf.isEquiv.symm ha
  have hxb : kf.rel x b := kf.isEquiv.symm hb
  have hab : kf.rel a b := kf.isEquiv.trans (kf.isEquiv.symm hxa) hxb
  exact h hab

/-- Number taxonomy: NUMBER has subkinds ℕ, ℤ, ℚ, ℝ, etc.
    TWO has subkinds 2_ℕ, 2_ℤ, 2_ℚ, 2_ℝ (Snyder §4.3). -/
inductive NumberSystem where
  | nat | int | rat | real
  deriving DecidableEq, BEq, Repr

instance : Fintype NumberSystem where
  elems := {.nat, .int, .rat, .real}
  complete := by intro x; cases x <;> simp

/-- Two twos from different systems are distinct subkinds of TWO. -/
def twoSubkinds : NumberSystem → NumberSystem → Prop := (· ≠ ·)

/-- The four number systems. -/
def NumberSystem.all : List NumberSystem := [.nat, .int, .rat, .real]

/-- NUMBER has four subkinds (ℕ, ℤ, ℚ, ℝ).
    This is what makes taxonomic predication ("two comes in several
    varieties") felicitous: the kind TWO has genuinely distinct subkinds. -/
theorem numberSystem_count : NumberSystem.all.length = 4 := rfl

/-- All pairs of distinct number systems yield distinct subkinds. -/
theorem twoSubkinds_of_ne (s₁ s₂ : NumberSystem) (h : s₁ ≠ s₂) :
    twoSubkinds s₁ s₂ := h

end KindFormation

end Semantics.Lexical.Noun.Kind.Chierchia1998
