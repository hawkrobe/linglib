import Linglib.Theories.Semantics.Modality.Kratzer
import Linglib.Core.Presupposition
import Linglib.Core.CommonGround

/-!
# Kernel Semantics for Epistemic Modals

Von Fintel & Gillies (2010, 2021) kernel semantics. Epistemic modals carry an
evidential presupposition that the prejacent is not *directly settled* by the
kernel K ⊆ B_K. The central result (`entailment_settling_gap`) is that B_K can
entail φ without K directly settling it, making the presupposition non-trivial.

The 2021 paper extends the analysis to *can't*, exposing a dilemma for the
weakness Mantra: no assignment of force to *can't* simultaneously explains its
evidential distribution (Observation 4) and its incompatibility with *it's
possible* (Observation 5). Kernel semantics resolves this because *can't φ* =
*must*(¬φ) is simultaneously strong and evidentially constrained.

## References

- von Fintel, K. & Gillies, A. (2010). Must...stay...strong! NLS 18:351–383.
- von Fintel, K. & Gillies, A. (2021). Still going strong. NLS 29:91–113.
-/

namespace Semantics.Modality

open Semantics.Attitudes.Intensional
open Semantics.Modality.Kratzer
open Core.Presupposition
open Core.Proposition
open Core.CommonGround

/-! ## Helpers -/

/-- `(L.filter f).isEmpty = L.all (λ x => !f x)`: a filtered list is empty
iff every element fails the predicate. -/
private theorem filter_isEmpty_eq_all_not {α : Type}
    (L : List α) (f : α → Bool) :
    (L.filter f).isEmpty = L.all (λ x => !f x) := by
  induction L with
  | nil => rfl
  | cons a t ih =>
    cases hfa : f a <;> simp_all [List.isEmpty]

/-- `propIntersection (φ :: A) = (propIntersection A).filter φ`:
adding a proposition to the list intersects the base with ⟦φ⟧. -/
private theorem propIntersection_cons (φ : BProp World) (A : List (BProp World)) :
    propIntersection (φ :: A) = (propIntersection A).filter φ := by
  unfold propIntersection
  rw [List.filter_filter]
  apply List.filter_congr
  intro w _
  simp only [List.all_cons]

/-! ## Kernel structure (VF&G 2010 Def 4) -/

/-- A kernel: a set of direct-information propositions with B_K = ⋂K. -/
structure Kernel where
  props : List (BProp World)

namespace Kernel

/-- B_K = ⋂K. -/
def base (k : Kernel) : List World :=
  propIntersection k.props

/-- Convert to a context-independent modal base. -/
def toModalBase (k : Kernel) : ModalBase :=
  λ _ => k.props

/-- Consistency: B_K ≠ ∅. -/
def isConsistent (k : Kernel) : Bool :=
  Kratzer.isConsistent k.props

/-- φ follows from K iff B_K ⊆ ⟦φ⟧. -/
def followsFrom (k : Kernel) (φ : BProp World) : Bool :=
  Kratzer.followsFrom φ k.props

/-- Induce an `EpistemicFlavor` for Kratzer modal evaluation. -/
def toEpistemicFlavor (k : Kernel) : EpistemicFlavor where
  evidence := k.toModalBase
  ordering := emptyBackground

/-- View a common ground as a kernel. -/
def ofCG (cg : CG World) : Kernel where
  props := cg.propositions

end Kernel

/-- World-dependent kernel assignment K^c(w). -/
abbrev KernelBackground := World → Kernel

namespace KernelBackground

/-- Convert to a Kratzer modal base. -/
def toModalBase (kb : KernelBackground) : ModalBase :=
  λ w => (kb w).props

end KernelBackground

/-! ## Settling (VF&G 2010 Def 5) -/

/-- K directly settles P iff some X ∈ K entails P or is incompatible with P
(Implementation 1). -/
def directlySettlesExplicit (k : Kernel) (φ : BProp World) : Bool :=
  k.props.any λ x =>
    (propExtension x).all φ ||          -- X ⊆ ⟦φ⟧
    !(propExtension x).any φ            -- X ∩ ⟦φ⟧ = ∅

/-- Refine a partition along φ-boundaries (VF&G 2010 subject matter). -/
def refine (partition : List (List World)) (φ : BProp World) : List (List World) :=
  partition.flatMap λ cell =>
    let pos := cell.filter φ
    let neg := cell.filter (λ w => !φ w)
    [pos, neg].filter (·.length > 0)

/-- The partition S_K generated by K (VF&G 2010 Def 7). -/
def kernelPartition (k : Kernel) : List (List World) :=
  k.props.foldl refine [allWorlds]

/-- K settles P via partition iff P is a union of cells in S_K
(Implementation 2). -/
def settlesByPartition (k : Kernel) (φ : BProp World) : Bool :=
  let sK := kernelPartition k
  sK.all λ cell => cell.all φ || cell.all (λ w => !φ w)

/-- B_K ⊆ ⟦X⟧ for each X ∈ K: every world in the modal base belongs
    to each kernel proposition's extension. -/
private theorem mem_propExtension_of_propIntersection
    {x : BProp World} {props : List (BProp World)}
    (hx : x ∈ props) {w : World} (hw : w ∈ propIntersection props) :
    w ∈ propExtension x := by
  simp only [propExtension, propIntersection, List.mem_filter, List.all_eq_true] at hw ⊢
  exact ⟨hw.1, hw.2 x hx⟩

/-- What both implementations share: settling implies entailment.
    If K directly settles φ (Implementation 1), then B_K ⊆ ⟦φ⟧ or B_K ⊆ ⟦¬φ⟧.
    If X ∈ K entails φ then B_K ⊆ X ⊆ ⟦φ⟧; if X excludes φ then
    B_K ⊆ X ⊆ ⟦¬φ⟧. -/
theorem explicit_implies_entailment (k : Kernel) (φ : BProp World)
    (h : directlySettlesExplicit k φ = true) :
    k.followsFrom φ = true ∨ k.followsFrom (λ w => !φ w) = true := by
  unfold directlySettlesExplicit at h
  obtain ⟨x, hx_mem, hx⟩ := List.any_eq_true.mp h
  simp only [Bool.or_eq_true] at hx
  unfold Kernel.followsFrom
  cases hx with
  | inl h_ent =>
    left
    exact List.all_eq_true.mpr λ w hw =>
      List.all_eq_true.mp h_ent w (mem_propExtension_of_propIntersection hx_mem hw)
  | inr h_exc =>
    right
    exact List.all_eq_true.mpr λ w hw => by
      have hw_ext := mem_propExtension_of_propIntersection hx_mem hw
      cases hφ : φ w with
      | false => rfl
      | true =>
        exfalso
        have := List.any_eq_true.mpr ⟨w, hw_ext, hφ⟩
        simp [this] at h_exc

/-- Two worlds are co-located in a partition if some cell contains both. -/
private def CoLocated (partition : List (List World)) (w v : World) : Prop :=
  ∃ cell ∈ partition, w ∈ cell ∧ v ∈ cell

/-- Refining preserves co-location for worlds that agree on the proposition. -/
private theorem refine_preserves_colocated
    (partition : List (List World)) (p : BProp World)
    {w v : World} (h : CoLocated partition w v) (h_agree : p w = p v) :
    CoLocated (refine partition p) w v := by
  obtain ⟨cell, h_cell, hw, hv⟩ := h
  unfold refine
  cases hp : p w with
  | true =>
    have hpv : p v = true := h_agree ▸ hp
    refine ⟨cell.filter p, ?_, List.mem_filter.mpr ⟨hw, hp⟩, List.mem_filter.mpr ⟨hv, hpv⟩⟩
    exact List.mem_flatMap.mpr ⟨cell, h_cell, List.mem_filter.mpr
      ⟨.head _, decide_eq_true_iff.mpr
        (List.length_pos_of_mem (List.mem_filter.mpr ⟨hw, hp⟩))⟩⟩
  | false =>
    have hpv : p v = false := h_agree ▸ hp
    refine ⟨cell.filter (λ w => !p w), ?_,
      List.mem_filter.mpr ⟨hw, by simp [hp]⟩, List.mem_filter.mpr ⟨hv, by simp [hpv]⟩⟩
    exact List.mem_flatMap.mpr ⟨cell, h_cell, List.mem_filter.mpr
      ⟨.tail _ (.head _), decide_eq_true_iff.mpr
        (List.length_pos_of_mem (List.mem_filter.mpr ⟨hw, by simp [hp]⟩))⟩⟩

/-- Folding refine over a list of propositions preserves co-location for
    worlds that agree on all propositions in the list. -/
private theorem foldl_refine_preserves_colocated
    (props : List (BProp World)) (partition : List (List World))
    {w v : World} (h : CoLocated partition w v)
    (h_agree : ∀ p ∈ props, p w = p v) :
    CoLocated (props.foldl refine partition) w v := by
  induction props generalizing partition with
  | nil => exact h
  | cons p ps ih =>
    simp only [List.foldl_cons]
    exact ih (refine partition p)
      (refine_preserves_colocated partition p h (h_agree p (.head _)))
      (λ q hq => h_agree q (.tail _ hq))

/-- Co-located worlds in a settled partition have the same φ-value. -/
private theorem colocated_same_phi
    (partition : List (List World)) (φ : BProp World)
    (h_settled : partition.all
      (λ cell => cell.all φ || cell.all (λ w => !φ w)) = true)
    {w v : World} (h_coloc : CoLocated partition w v) :
    φ w = φ v := by
  obtain ⟨cell, h_cell, hw, hv⟩ := h_coloc
  have h_uniform := List.all_eq_true.mp h_settled cell h_cell
  simp only [Bool.or_eq_true] at h_uniform
  cases h_uniform with
  | inl h_all_phi =>
    have := List.all_eq_true.mp h_all_phi w hw
    have := List.all_eq_true.mp h_all_phi v hv
    simp_all
  | inr h_all_neg =>
    have hw_neg := List.all_eq_true.mp h_all_neg w hw
    have hv_neg := List.all_eq_true.mp h_all_neg v hv
    simp only [Bool.not_eq_true'] at hw_neg hv_neg
    simp [hw_neg, hv_neg]

/-- Partition settling implies entailment: if S_K settles φ then
    B_K ⊆ ⟦φ⟧ or B_K ⊆ ⟦¬φ⟧. All worlds in B_K agree on every X ∈ K
    (they all satisfy every X), so they occupy a single cell of S_K.
    If that cell is φ-uniform, B_K inherits the uniformity. -/
theorem partition_implies_entailment (k : Kernel) (φ : BProp World)
    (h : settlesByPartition k φ = true) :
    k.followsFrom φ = true ∨ k.followsFrom (λ w => !φ w) = true := by
  unfold settlesByPartition at h
  unfold Kernel.followsFrom followsFrom
  cases h_bk : propIntersection k.props with
  | nil => left; simp
  | cons w₀ ws =>
    have hw₀_bk : w₀ ∈ propIntersection k.props := h_bk ▸ .head _
    have hw₀_all : w₀ ∈ allWorlds := by
      simp only [propIntersection, List.mem_filter] at hw₀_bk; exact hw₀_bk.1
    have hw₀_props : k.props.all (λ p => p w₀) = true := by
      simp only [propIntersection, List.mem_filter] at hw₀_bk; exact hw₀_bk.2
    cases hφ : φ w₀ with
    | true =>
      left; rw [← h_bk]
      exact List.all_eq_true.mpr λ w hw => by
        have hw_props : k.props.all (λ p => p w) = true := by
          simp only [propIntersection, List.mem_filter] at hw; exact hw.2
        have h_agree : ∀ p ∈ k.props, p w₀ = p w := λ p hp => by
          have := List.all_eq_true.mp hw₀_props p hp
          have := List.all_eq_true.mp hw_props p hp; simp_all
        have h_coloc := foldl_refine_preserves_colocated k.props [allWorlds]
          ⟨allWorlds, .head _, hw₀_all, by
            simp only [propIntersection, List.mem_filter] at hw; exact hw.1⟩
          h_agree
        have h_same := colocated_same_phi (kernelPartition k) φ h h_coloc
        unfold kernelPartition at h_same; rw [← h_same, hφ]
    | false =>
      right; rw [← h_bk]
      exact List.all_eq_true.mpr λ w hw => by
        have hw_props : k.props.all (λ p => p w) = true := by
          simp only [propIntersection, List.mem_filter] at hw; exact hw.2
        have h_agree : ∀ p ∈ k.props, p w₀ = p w := λ p hp => by
          have := List.all_eq_true.mp hw₀_props p hp
          have := List.all_eq_true.mp hw_props p hp; simp_all
        have h_coloc := foldl_refine_preserves_colocated k.props [allWorlds]
          ⟨allWorlds, .head _, hw₀_all, by
            simp only [propIntersection, List.mem_filter] at hw; exact hw.1⟩
          h_agree
        have h_same := colocated_same_phi (kernelPartition k) φ h h_coloc
        unfold kernelPartition at h_same; simp [← h_same, hφ]

/-! ## Modal operators (VF&G 2010 Defs 5–6) -/

/-- ⟦must φ⟧: presupposes K doesn't settle φ; asserts B_K ⊆ ⟦φ⟧. -/
def kernelMust (k : Kernel) (φ : BProp World) : PrProp World :=
  { presup := λ _ => !directlySettlesExplicit k φ
  , assertion := λ _ => Kratzer.followsFrom φ k.props }

/-- ⟦might φ⟧: presupposes K doesn't settle φ; asserts B_K ∩ ⟦φ⟧ ≠ ∅. -/
def kernelMight (k : Kernel) (φ : BProp World) : PrProp World :=
  { presup := λ _ => !directlySettlesExplicit k φ
  , assertion := λ _ => isCompatibleWith φ k.props }

/-- ⟦can't φ⟧ = must(¬φ). -/
def kernelCant (k : Kernel) (φ : BProp World) : PrProp World :=
  kernelMust k (λ w => !φ w)

/-- World-dependent ⟦must φ⟧. -/
def kernelMustW (kb : KernelBackground) (φ : BProp World) : PrProp World :=
  { presup := λ w => !directlySettlesExplicit (kb w) φ
  , assertion := λ w => Kratzer.followsFrom φ (kb w).props }

/-- World-dependent ⟦might φ⟧. -/
def kernelMightW (kb : KernelBackground) (φ : BProp World) : PrProp World :=
  { presup := λ w => !directlySettlesExplicit (kb w) φ
  , assertion := λ w => isCompatibleWith φ (kb w).props }

/-! ## Core properties -/

/-- Must is strong: when defined, must φ = universal necessity over B_K. -/
theorem must_is_strong (k : Kernel) (φ : BProp World) (w : World)
    (_hDef : (kernelMust k φ).presup w = true) :
    (kernelMust k φ).assertion w = simpleNecessity k.toModalBase φ w := by
  unfold kernelMust simpleNecessity accessibleWorlds Kernel.toModalBase followsFrom
  rfl

/-- T axiom: must φ entails φ when B_K is realistic (w ∈ B_K). -/
theorem must_entails_prejacent (k : Kernel) (φ : BProp World) (w : World)
    (hReal : w ∈ k.base)
    (_hDef : (kernelMust k φ).presup w = true)
    (hTrue : (kernelMust k φ).assertion w = true) :
    φ w = true := by
  unfold kernelMust at hTrue
  unfold followsFrom at hTrue
  unfold Kernel.base at hReal
  exact List.all_eq_true.mp hTrue w hReal

/-- Duality: might φ ↔ ¬(must ¬φ) in assertion content. -/
theorem kernel_duality (k : Kernel) (φ : BProp World) (w : World) :
    (kernelMight k φ).assertion w = !(kernelMust k (λ w' => !φ w')).assertion w := by
  simp only [kernelMight, kernelMust, isCompatibleWith, isConsistent, followsFrom]
  rw [propIntersection_cons, filter_isEmpty_eq_all_not]

/-- Empty kernel: nothing is settled, so must is always defined. -/
theorem empty_kernel_always_defined (φ : BProp World) (w : World) :
    (kernelMust ⟨[]⟩ φ).presup w = true := by
  simp only [kernelMust, directlySettlesExplicit, List.any_nil, Bool.not_false]

/-! ## Bridge to Kratzer.lean -/

/-- Kernel must assertion = Kratzer simple necessity. -/
theorem kernelMust_eq_simpleNecessity (k : Kernel) (φ : BProp World) (w : World) :
    (kernelMust k φ).assertion w = simpleNecessity k.toModalBase φ w := by
  unfold kernelMust simpleNecessity accessibleWorlds Kernel.toModalBase followsFrom
  rfl

/-! ## Mastermind example (VF&G 2010 pp. 365–366)

w0 = red, w1 = blue, w2 = green, w3 = unknown.
K = {redOrBlue, notRed}, B_K = {w1}. -/

private def redOrBlue : BProp World := λ w => match w with | .w0 => true | .w1 => true | _ => false
private def notRed : BProp World := λ w => match w with | .w0 => false | _ => true
private def blue : BProp World := λ w => match w with | .w1 => true | _ => false
private def red : BProp World := λ w => match w with | .w0 => true | _ => false
private def notBlue : BProp World := λ w => match w with | .w1 => false | _ => true

private def mastermindK : Kernel := ⟨[redOrBlue, notRed]⟩
private def indirectK : Kernel := ⟨[redOrBlue]⟩

theorem mastermind_base : mastermindK.base = [.w1] := by native_decide

theorem mastermind_blue_unsettled :
    directlySettlesExplicit mastermindK blue = false := by native_decide

theorem mastermind_blue_follows :
    mastermindK.followsFrom blue = true := by native_decide

theorem mastermind_must_blue_defined :
    (kernelMust mastermindK blue).presup .w0 = true := by native_decide

theorem mastermind_must_blue_true :
    (kernelMust mastermindK blue).assertion .w0 = true := by native_decide

theorem mastermind_red_settled :
    directlySettlesExplicit mastermindK red = true := by native_decide

theorem mastermind_might_red_undefined :
    (kernelMight mastermindK red).presup .w0 = false := by native_decide

theorem mastermind_redOrBlue_settled :
    directlySettlesExplicit mastermindK redOrBlue = true := by native_decide

/-! ## Non-equivalence of the two implementations (VF&G 2010 §7, p. 379)

The explicit and partition-based implementations of "directly settles" are
non-equivalent. Implementation 1 settles supersets of K-propositions that
Implementation 2 misses; Implementation 2 settles propositions determined
jointly by K-propositions that no single proposition settles. Both, however,
imply entailment (see `explicit_implies_entailment` and
`partition_implies_entailment` above). -/

/-- Counterexample (Impl 1 ↛ Impl 2): K = {red}, φ = redOrBlue.
    red ⊆ redOrBlue so Impl 1 settles, but S_K = {{w0},{w1,w2,w3}}
    and the cell {w1,w2,w3} straddles redOrBlue. -/
theorem explicit_not_implies_partition :
    ∃ (k : Kernel) (φ : BProp World),
      directlySettlesExplicit k φ = true ∧ settlesByPartition k φ = false :=
  ⟨⟨[red]⟩, redOrBlue, by native_decide, by native_decide⟩

/-- Counterexample (Impl 2 ↛ Impl 1): K = mastermindK, φ = blue.
    No single X ∈ K entails or excludes blue, but S_K = {{w0},{w1},{w2,w3}}
    resolves blue into a union of cells. -/
theorem partition_not_implies_explicit :
    ∃ (k : Kernel) (φ : BProp World),
      settlesByPartition k φ = true ∧ directlySettlesExplicit k φ = false :=
  ⟨mastermindK, blue, by native_decide, by native_decide⟩

/-- Entailment does not imply partition settling: B_K ⊆ ⟦φ⟧ does not
    guarantee S_K settles φ. Same witness as explicit_not_implies_partition:
    K = {red} entails redOrBlue (B_K = {w0} ⊆ ⟦redOrBlue⟧) but the partition
    cell {w1,w2,w3} straddles redOrBlue. -/
theorem entailment_not_implies_partition :
    ∃ (k : Kernel) (φ : BProp World),
      k.followsFrom φ = true ∧ settlesByPartition k φ = false :=
  ⟨⟨[red]⟩, redOrBlue, by native_decide, by native_decide⟩

/-! ## Deep theorems (VF&G 2010) -/

/-- **Entailment-settling gap**: B_K can entail φ without K settling it.
This gap makes the evidential presupposition non-trivial: must φ can be
simultaneously defined and true. -/
theorem entailment_settling_gap :
    ∃ (k : Kernel) (φ : BProp World),
      k.followsFrom φ = true ∧ directlySettlesExplicit k φ = false :=
  ⟨mastermindK, blue, by native_decide, by native_decide⟩

/-- **Indirectness ≠ weakness**: three independent cases show indirectness
and assertion strength are orthogonal dimensions. -/
theorem indirectness_neq_weakness :
    ((kernelMust mastermindK blue).presup .w0 = true ∧
     (kernelMust mastermindK blue).assertion .w0 = true) ∧
    (kernelMust mastermindK red).presup .w0 = false ∧
    ((kernelMust indirectK blue).presup .w0 = true ∧
     (kernelMust indirectK blue).assertion .w0 = false) := by native_decide

/-- **Modus ponens with must** (VF&G 2010 Arg 4.3.1): the argument form
"if φ, must ψ; φ; ∴ ψ" is valid under realistic B_K. -/
theorem modus_ponens_with_must (k : Kernel) (φ ψ : BProp World) (w : World)
    (hReal : w ∈ k.base)
    (_hDef : (kernelMust k ψ).presup w = true)
    (hCond : φ w = true → (kernelMust k ψ).assertion w = true)
    (hPhi : φ w = true) :
    ψ w = true :=
  must_entails_prejacent k ψ w hReal _hDef (hCond hPhi)

/-- **Must-perhaps contradiction** (VF&G 2010 Arg 4.3.2): must φ ∧ might ¬φ
is contradictory. When B_K ⊆ ⟦φ⟧, we have B_K ∩ ⟦¬φ⟧ = ∅. -/
theorem must_perhaps_contradiction (k : Kernel) (φ : BProp World) (w : World)
    (_hDef : (kernelMust k φ).presup w = true)
    (hMust : (kernelMust k φ).assertion w = true) :
    (kernelMight k (λ w' => !φ w')).assertion w = false := by
  rw [kernel_duality]
  simp only [kernelMust] at hMust ⊢
  simp only [followsFrom, propIntersection] at hMust ⊢
  simp [hMust]

/-- Direct evidence infelicity: when K settles φ, must φ is undefined. -/
theorem direct_evidence_infelicity (k : Kernel) (φ : BProp World) (w : World)
    (hSettled : directlySettlesExplicit k φ = true) :
    (kernelMust k φ).presup w = false := by
  simp only [kernelMust, hSettled, Bool.not_true]

/-- Settling is monotone: more propositions in K means more is settled. -/
theorem settling_monotone (k : Kernel) (p : BProp World) (φ : BProp World)
    (hSettled : directlySettlesExplicit k φ = true) :
    directlySettlesExplicit ⟨p :: k.props⟩ φ = true := by
  simp only [directlySettlesExplicit, List.any_cons] at *
  simp [hSettled]

/-! ## Can't dilemma (VF&G 2021 §4, Observations 4–5)

The Mantra faces a dilemma: no assignment of force to *can't* simultaneously
explains its evidential distribution (paralleling must) and its incompatibility
with *it's possible that φ*. Kernel semantics resolves this because
*can't φ* = *must*(¬φ) is strong AND evidentially constrained. -/

/-- **Can't–might exclusion** (VF&G 2021 Obs 5): when can't φ holds
(B_K ⊆ ⟦¬φ⟧), might φ is false (B_K ∩ ⟦φ⟧ = ∅). -/
theorem cant_might_exclusion (k : Kernel) (φ : BProp World) (w : World)
    (hCant : (kernelCant k φ).assertion w = true) :
    (kernelMight k φ).assertion w = false := by
  rw [kernel_duality]
  simp only [kernelCant, kernelMust] at hCant ⊢
  simp only [followsFrom, propIntersection] at hCant ⊢
  simp [hCant]

/-- **Can't entails negation** (VF&G 2021 via S2): when B_K is realistic
and can't φ is defined and true, φ(w) = false. -/
theorem cant_entails_negation (k : Kernel) (φ : BProp World) (w : World)
    (hReal : w ∈ k.base)
    (_hDef : (kernelCant k φ).presup w = true)
    (hTrue : (kernelCant k φ).assertion w = true) :
    φ w = false := by
  have hNeg := must_entails_prejacent k (λ w' => !φ w') w hReal _hDef hTrue
  simp only [Bool.not_eq_true'] at hNeg
  exact hNeg

/-- **Can't evidential parallelism** (VF&G 2021 Obs 4): can't φ has the
same presupposition structure as must(¬φ). -/
theorem cant_evidential_parallel (k : Kernel) (φ : BProp World) (w : World) :
    (kernelCant k φ).presup w = (kernelMust k (λ w' => !φ w')).presup w := rfl

/-- **Can't dilemma resolved**: a single kernel simultaneously exhibits
evidentiality, strength, and might-exclusion.
Witness: K = {redOrBlue, notRed}, φ = notBlue. Then can't(notBlue) =
must(blue), which is defined (blue unsettled), true (B_K ⊆ ⟦blue⟧),
and excludes might(notBlue). -/
theorem cant_dilemma_resolved :
    mastermindK.base.elem .w1 = true ∧
    (kernelCant mastermindK notBlue).presup .w1 = true ∧
    (kernelCant mastermindK notBlue).assertion .w1 = true ∧
    (kernelMight mastermindK notBlue).assertion .w1 = false ∧
    notBlue .w1 = false := by native_decide

/-- Direct evidence blocks can't, paralleling must: when K settles ¬φ,
can't φ has presupposition failure. -/
theorem cant_direct_evidence_infelicity :
    (kernelCant mastermindK red).presup .w0 = false := by native_decide

/-- can't φ and must(¬φ) are intensionally identical. -/
theorem cant_eq_must_neg (k : Kernel) (φ : BProp World) (w : World) :
    (kernelCant k φ).presup w = (kernelMust k (λ w' => !φ w')).presup w ∧
    (kernelCant k φ).assertion w = (kernelMust k (λ w' => !φ w')).assertion w :=
  ⟨rfl, rfl⟩

/-! ## Prior information state and nandao-Q felicity (Zheng 2026)

Zheng (2026) shows Mandarin *nandao*-Qs are evidence-driven, not bias-driven.
The felicity condition has three parts: (i) evidence in K supports the prejacent,
(ii) K conflicts with prior expectations U, (iii) the prejacent is not directly
settled in K. Condition (iii) is the same presupposition as `kernelMust`. -/

/-- Prior information state (beliefs, norms, desires) before encountering
evidence. Distinct from the kernel (direct evidence) and the CG (shared). -/
abbrev Background := List (BProp World)

/-- B_U = ⋂U: worlds compatible with the prior information state. -/
def backgroundBase (u : Background) : List World :=
  propIntersection u

/-- K and U are incompatible: B_K ∩ B_U = ∅ (the evidence is unexpected). -/
def Kernel.incompatibleWith (k : Kernel) (u : Background) : Bool :=
  !(Kratzer.isConsistent (k.props ++ u))

/-- Evidence p raises the probability of φ: P(φ|p) > P(φ).
Computed via cross-multiplication to avoid rationals. -/
def evidenceRaises (p φ : BProp World) : Bool :=
  let pWorlds := propExtension p
  let phiInP := (pWorlds.filter φ).length
  let phiInAll := (allWorlds.filter φ).length
  phiInP * allWorlds.length > phiInAll * pWorlds.length

/-- Some proposition in K raises the probability of φ (condition i). -/
def Kernel.evidenceSupports (k : Kernel) (φ : BProp World) : Bool :=
  k.props.any (evidenceRaises · φ)

/-- **Nandao-Q felicity** (Zheng 2026, condition 11 for polar questions):
(i) some evidence in K raises P(φ),
(ii) K and U are incompatible (evidence is unexpected),
(iii) φ is not directly settled in K. -/
def nandaoFelicitous (k : Kernel) (u : Background) (φ : BProp World) : Bool :=
  k.evidenceSupports φ &&
  k.incompatibleWith u &&
  !directlySettlesExplicit k φ

/-- Nandao condition (iii) = presupposition of `kernelMust`. -/
theorem nandao_must_presupposition (k : Kernel) (φ : BProp World) (w : World) :
    (!directlySettlesExplicit k φ) = (kernelMust k φ).presup w := rfl

/-- Pure inquiry: nandao is felicitous without epistemic bias (Zheng 2026 ex. 3).
The three conditions suffice; no prior belief about φ is required. -/
theorem nandao_pure_inquiry (k : Kernel) (u : Background) (φ : BProp World)
    (hEv : k.evidenceSupports φ = true)
    (hInc : k.incompatibleWith u = true)
    (hUns : directlySettlesExplicit k φ = false) :
    nandaoFelicitous k u φ = true := by
  simp only [nandaoFelicitous, hEv, hInc, hUns, Bool.not_false, Bool.true_and]

/-! ### Dripping raincoat scenario (Zheng 2026 exx. 2–3, 5)

w0 = raining, w1 = sprinkler (wet but not rain), w2 = dry, w3 = unknown.
K = {wearingRaincoat}: direct evidence that someone entered with a wet coat.
U = {expectDry}: prior expectation of no rain (normative or doxastic). -/

private def wearingRaincoat : BProp World :=
  λ w => match w with | .w0 => true | .w1 => true | _ => false
private def expectDry : BProp World :=
  λ w => match w with | .w2 => true | .w3 => true | _ => false
private def isRaining : BProp World :=
  λ w => match w with | .w0 => true | _ => false

private def raincoatK : Kernel := ⟨[wearingRaincoat]⟩
private def dryU : Background := [expectDry]

/-- "Nandao waimian xiayu-le ma?" is felicitous with a dripping raincoat.
P(rain|coat) = 1/2 > P(rain) = 1/4; K ∩ U = ∅; rain unsettled by K. -/
theorem raincoat_nandao_felicitous :
    nandaoFelicitous raincoatK dryU isRaining = true := by native_decide

/-- Without evidence, nandao is infelicitous (Zheng 2026 ex. 5 ctx 2). -/
theorem no_evidence_nandao_infelicitous :
    nandaoFelicitous ⟨[]⟩ dryU isRaining = false := by native_decide

/-- When evidence is expected (K compatible with U), nandao is infelicitous
(Zheng 2026 ex. 6 ctx 2). -/
theorem expected_evidence_infelicitous :
    let expectWet : Background := [wearingRaincoat]
    nandaoFelicitous raincoatK expectWet isRaining = false := by native_decide

/-- Nandao reuses the mastermind kernel: "must blue" and "nandao blue?" share
condition (iii). When must is defined, nandao's indirectness condition holds. -/
theorem nandao_mastermind_bridge :
    (kernelMust mastermindK blue).presup .w0 = true ∧
    !directlySettlesExplicit mastermindK blue = true := by native_decide

end Semantics.Modality
